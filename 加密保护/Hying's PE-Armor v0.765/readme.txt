;-------------------hying's PE-Armor是一个通用PE压缩程序。----------------------------------
;本程序由hying于2001年9月开始编写，由于编程经验的不断积累，发现在原始结构
;上存在较大的缺陷，不利于程序的继续改进。所以在2002年上半年曾经全部重写。
;主要技术特点：
;1。在加密过程中对调用输入表的CALL和JMP等指令进行了加密，使程序不能脱离外壳运行。
;     此方法参考了Krypton v0.3，但兼容性较前者要好。
;2。加密时改写了程序入口点的特征代码，防止了冲击波2000的查找入口。(Krypton v0.4也有类似处理)
;3。修改入口代码后也防止了Import REConstructor的自动查找输入表地址。
;4。加密了KERNEL32。DLL等连接库的输入表，可有效防止ImpRE的直接重建。
;5. 参考ASPROCTECT将GetCommandlLineA,GetVersion等特殊函数进行了特殊处理.
;   同时监视了LoadLibrary和GetProcAddress函数,以便做某些特殊使用.
;6。通过SEH改写DRX，在代码中设置断点，并利用这些断点进行解码。
;     此方法参考了TELOCK0.98，其只判断断点是否成功，容易被绕过，本程序的方法保密性更好。
;7。在解码过程中修改了ESP的值，这样可有效防止RING 3级调试器在该段代码中插INT 3设断。
;8。使用了ANTI-DUMP技术,
;9。支持DLL的处理。
;10.使用了APLIB压缩库，有较好的压缩效果。
;11.在压缩时对一些代码做了优化,使压缩率更高。(抄袭PECompact而来）
;12.对外壳起始代码做了处理，加壳后的程序会被FI认为是TELOCK0.98
;13.外壳中调用API时先将API入口处的部分代码拷贝至本地内存执行，然后从中间进入，防止设API断点。
;     （参考LJTT的外壳得来，但实现方法不一样。可能他的比较好，因为我的不能重入） 
;14.加密程序中指定的代码，并提供用于在程序中动态解密的函数以供调用。(需在编程时设置标志)
;15.在外壳中执行指定的程序初始化函数，一旦脱壳，程序没有正确初始化，将执行错误。(需在编程时设置标志)
;16.可以模仿pecompact\telock0.98\upx\Krypton0.4等外壳,让FI等外壳测试软件判断错误
;17.针对VB程序的结构,可做一些特殊处理,彻底丢弃了输入表,防止重建.
;18.针对delphi可做一些特殊处理，使脱壳后的程序无法运行。


如何更好的使用本外壳加密您的软件：
1.选择‘特殊代码加密’可对程序中的某些代码进行处理，不通过编程将很难将改变的代码还原，有效提高加密后软件的安全性。
2.选择‘输入表加密’可对程序的输入表进行处理，在程序运行的任何时间，内存中都不会出现完整的输入表。并且采用的算法可有效抵抗Import REConstructor等还原工具的自动还原。
3.使用‘输入表加密’后程序将监视LoadLibrary和GetProcAddress函数，利用它可以判断程序是否带外壳执行。比如利用LoadLibrary载入一个名为XDLL.DLL的文件时带外壳执行时将返回0x78787878，不带外壳时无论是否找到XDLL.DLL，都不可能得到上述的返回值。调用GetProcAddress函数时如果第一个调用参数为0x69696969时将返回1，无外壳时将返回0，比如如下调用:CALL GetProcAddress 69696969h,0
4.外壳中内置了一个链接库XDLL.DLL。除使用上面的方法检测外壳外还可以通过调用SDLL.DLL中的函数来判断外壳。使用方法是先利用LoadLibrary取得DLL句柄(有外壳时将是0x78787878)，然后利用GetProcAddress根据刚才取得的句柄获取函数的地址，最后调用函数就可以了。外壳的处理对编程者是透明的，只需要按照一般的方法调用就可以了。再未加壳时程序必须找到真实存在的XDLL.DLL，并且XDLL.DLL中有相应功能的函数，程序才能运行。加壳后，这些功能都被内置在外壳中，无须XDLL.DLL也能运行。程序发布时将不附带XDLL.DLL。如果被脱壳，程序没有XDLL.DLL将无法运行。具体内置函数如下：
    (1). Func2Func函数。此函数的功能是函数转换。比如调用MessageBox的一般方法为：
         CALL	MessageBox, NULL, addr M_IsWorking, addr M_Warning, MB_OK 
         则调用Func2Func函数前应先取得MessageBox函数的入口地址为MessageBoxADDR，然后做如下调用：
         CALL	Func2Func, MessageBoxADDR, NULL, addr M_IsWorking, addr M_Warning, MB_OK
         产生的效果将和直接调用MessageBox函数相同。
    (2). TestDebug函数。此功能的作用是检测一些调试器，主要对象是TRW2000。建议在进行某个重要操作前调用一下。因为TRW2000可以在程序运行后运行，这样就绕过了外壳启动时的检测。在重要操作前调用可以防止TRW的中途启动。此函数没有进入参数和返回值，如发现调试器则程序退出或死锁。
    (3). EnCrypt和DeCrypt函数。他们的算法相对应，分别可以加密和解密一段代码。外壳在处理程序时会自动在程序的第一个区块中查找特殊的标记，一旦找到这个标记则会调用EnCrypt函数加密标记的代码。程序要使用这些代码时可以通过调用DeCrypt函数先解码，然后再执行，执行完毕后再可以调用EnCrypt函数来解密它。如果有多段代码采用这样的处理，则可以保证任何时刻内存中都没有完整的程序代码。一旦脱壳，没有了解密函数，程序就无法运行了。EnCrypt和DeCrypt函数都有3个调用参数，比如EnCrypt函数的定义为
EnCrypt   PROC	EnCryptAddr:DWORD,EnCryptSize:DWORD,EnCryptKeyAddr:DWORD，3个参数分别定义为为欲处理代码的地址，欲处理字节数和加解密密匙地址。本外壳采用的标记为0EBh,06h,0CCh,0CCh,0CDh,01h,90h,80h和0EBh,06h,0CCh,0CCh,0CDh,03h,90h,80h。在编程时加入他们分别作为待加密代码的开始与结束，以便于外壳的自动识别。外壳处理时将处理两标记之间的代码(不包括标记)，并把处理的字节数放入加密开始的标记中。在程序里调用时可以将EnCryptSize或DeCryptSize参数设置为0，这样的话程序会自动取出原来放入的处理字节数。加解密密匙地址一般取为0，这样程序将使用外壳的默认密匙进行处理，在高级选项中提供自定义密匙，选用后程序将使用自定义密匙对代码进行加密,如果将关键代码的密匙与注册码相联系，几乎可以保证在没有正确注册码的情况下不可能破解。
    (4)外壳执行时将查找标记0EBh,06h,0CCh,0CCh,0CDh,05h,90h,80h,找到的话将在执行到OEP之前先执行标记后面的代码,这些代码可以做一些初始化工作.比如申请一段内存用做临时存储区等等。如果程序被脱壳，初始化函数没有执行，那程序就无法正常的执行。


5.因为XDLL中的函数名有一定的意义，所以如果有上述的调用，建议在平时把函数名加密，以防止被解密者发现并猜测出其含义。
6.外壳执行过程中间会创建一个由操作系统页文件支持的特殊逻辑映象文件，文件名是ShellTmpMap，文件内容为'ShellMap'，程序在执行过程中间可以打开这个映象文件读取里面的内容，如果读取错误则可判断为已脱壳。读取完成后可以不使用UnmapViewOfFile函数来释放文件，当程序退出时外壳会截获ExitProcess函数，先释放映象文件，然后再退出。

9.ASM示例文件请查看test.asm，



PE-Armor 0.765
作者：Hying

2007加密与解密工具大礼包特别公开！

看雪学院
致力软件安全研究

a website on reverse engineering 
pediy forum

http://www.pediy.com
http://bbs.pediy.com



